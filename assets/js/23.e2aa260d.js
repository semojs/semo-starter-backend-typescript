(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{369:function(t,a,s){"use strict";s.r(a);var e=s(42),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"repl"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#repl"}},[t._v("#")]),t._v(" REPL")]),t._v(" "),s("p",[t._v("REPL(read-eval-print-loop)：交互式解析器，每一个现代的编程语言大概都有这类交互环境，在里面我们可以写一些简单的代码，做为一个快速了解和学习语言特性的工具。但是当 REPL 可以和框架或者业务项目结合以后，可以发挥出更大的作用。")]),t._v(" "),s("p",[t._v("这里不会介绍基本的 REPL 用法，这部分可以去看 Node 的"),s("a",{attrs:{href:"http://nodejs.cn/api/repl.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("官方文档"),s("OutboundLink")],1),t._v("；这里更多的是介绍我们为 REPL 增加的东西。")]),t._v(" "),s("h2",{attrs:{id:"启动-repl"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#启动-repl"}},[t._v("#")]),t._v(" 启动 REPL")]),t._v(" "),s("p",[t._v("Starter 定一个了一个 script，因此你可以有多种方式进入 REPL")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("npx semo repl\nsemo repl "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果全局安装了 Semo")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("npm")]),t._v(" run repl\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("yarn")]),t._v(" repl "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 如果全局安装了 yarn")]),t._v("\n")])])]),s("h2",{attrs:{id:"关于-hook-选项"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于-hook-选项"}},[t._v("#")]),t._v(" 关于 "),s("code",[t._v("--hook")]),t._v(" 选项")]),t._v(" "),s("p",[t._v("由于我们通过为 REPL 注入一些业务逻辑代码增加 REPL 的作用，但这个过程往往需要花一些时间，所以我们可以选择不注入任何业务来启动一个 REPL，如果指定了 "),s("code",[t._v("--hook")]),t._v("，就会调用各个插件和项目里的 "),s("code",[t._v("hook_repl")]),t._v(" 把数据和对象方法注入进去。")]),t._v(" "),s("p",[t._v("借助 "),s("code",[t._v("Semo")]),t._v(" 的配置扩展机制，我们在 "),s("code",[t._v(".semorc.json")]),t._v(" 里指定了 "),s("code",[t._v("hook:true")]),t._v("，这样就改变了 repl 命令的参数默认值，不用每次都传这个参数了。")]),t._v(" "),s("h2",{attrs:{id:"关于下划线"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于下划线"}},[t._v("#")]),t._v(" 关于下划线 _")]),t._v(" "),s("p",[t._v("我们习惯把 lodash 包加载进来的时候赋值给 "),s("code",[t._v("_")]),t._v("，甚至想把这个复制给全局变量，这样只需要包含一次，但是这样一来，如果我迭代 REPL 和项目的初始化就会出现冲突报错，所以我们全局里是没有 lodash 的 "),s("code",[t._v("_")]),t._v(" 的，我们通过 "),s("code",[t._v("Utils._")]),t._v(" 来获取到 Lodash。")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" Utils._.VERSION\n")])])]),s("h2",{attrs:{id:"关于退出"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于退出"}},[t._v("#")]),t._v(" 关于退出")]),t._v(" "),s("p",[t._v("默认 REPL 的退出只能通过 "),s("code",[t._v("ctrl+c")]),t._v(" 或者 "),s("code",[t._v("ctrl+d")]),t._v(" 或者 "),s("code",[t._v(".exit")]),t._v(" 来进行，这里我们加入了几个快捷的命令，"),s("code",[t._v("quit")]),t._v(", "),s("code",[t._v("q")]),t._v(", "),s("code",[t._v("exit")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"await"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#await"}},[t._v("#")]),t._v(" "),s("code",[t._v("await")])]),t._v(" "),s("p",[t._v("在开发Zignis 和这个脚手架时，"),s("code",[t._v("Node")]),t._v(" 的 REPL 本身还不支持 "),s("code",[t._v("await")]),t._v("，这里是模拟实现了这个机制，目的是可以触发执行项目中的一些 promise 或 generator 方法，目前经测试，单独的 Promise 方法也是可以执行得到结果的。在较新的 Node 版本下，如果只是查看一个 "),s("code",[t._v("Promise")]),t._v(" 的返回值，连 "),s("code",[t._v("await")]),t._v(" 都是不需要的。")]),t._v(" "),s("h2",{attrs:{id:"在-repl-访问数据库的例子"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在-repl-访问数据库的例子"}},[t._v("#")]),t._v(" 在 REPL 访问数据库的例子")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("yarn")]),t._v(" repl --hook\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" const "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" Account "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" await Semo.sequelize.db.load"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'db1'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" await Account.count"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("注意，这里的访问数据库不依赖任何项目的初始化和helper 函数，完全是 Semo 内置的能力。但是如果项目中根据钩子将项目的资源注入到 REPL，则可以在这里去调用项目指定的方法。注入到 REPL 的钩子如下方式调用：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// bin/semo/hooks/index.js")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" init "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'../../../init'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\nmodule"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n   * Implementation of hook_repl\n   * 为 REPL 注入初始化环境\n   */")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("async")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("hook_repl")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("await")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("init")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("这里要注意，由于把资源注入到了全局，所以是调用的 init()方法，通常情况下，可以通过 return 一个对象的方式，给 REPL 注入私有的对象。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),s("p",[t._v("本脚手架为 repl 注入了整个项目的 helpers 和 services，所以我们开发业务逻辑的时候可以先不定义接口，通过 REPL 来测试方法逻辑也是可以的。")])]),t._v(" "),s("h2",{attrs:{id:"访问-redis"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#访问-redis"}},[t._v("#")]),t._v(" 访问 Redis")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("yarn repl --hook\n>>> const redis = await Semo.redis.load('redis1')\n>>> await redis.keys('*')\n")])])]),s("h2",{attrs:{id:"注入的基础设施实现方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注入的基础设施实现方式"}},[t._v("#")]),t._v(" 注入的基础设施实现方式")]),t._v(" "),s("p",[t._v("基础设置一般都是第三方远程提供的服务，这里我们都可以进行封装和初始化，然后通过 "),s("code",[t._v("hook_repl")]),t._v(" 和 "),s("code",[t._v("hook_component")]),t._v(" 注入环境中给项目使用。对于需要跨项目复用的基础设施，还可以开发专门的 "),s("code",[t._v("Semo")]),t._v(" 插件进行跨项目共享。")])])}),[],!1,null,null,null);a.default=r.exports}}]);