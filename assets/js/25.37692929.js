(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{371:function(t,a,s){"use strict";s.r(a);var e=s(43),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"脚本管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#脚本管理"}},[t._v("#")]),t._v(" 脚本管理")]),t._v(" "),s("p",[t._v("后端服务，尤其是业务后端，经常需要写一些脚本，包括但不限于导入数据，处理数据，统计数据，导出数据等等。一旦多了以后就不好管理了，不知道哪些是一次性的，哪些是仍然在使用的。这里脚手架提供了统一的脚本管理方式。")]),t._v(" "),s("h2",{attrs:{id:"创建一个脚本样板文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建一个脚本样板文件"}},[t._v("#")]),t._v(" \b创建一个脚本样板文件")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("semo generate script test\n./bin/semo/scripts/20190426134151995_test.ts created!\n")])])]),s("p",[t._v("生成的样板文件大致如下：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("import { Utils } from '@semo/core'\n\nexport const builder = function (yargs) {\n  // yargs.option('option', {default, describe, alias})\n}\n\nexport const handler = async function (argv) {\n  Utils.info('I am a test script!', true)\n}\n\n")])])]),s("p",[t._v("注意到，这里生成的脚本和计划任务或者命令都比较相似，也是一个 node 模块，返回的对象里包括两个属性：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("builder: 定义脚本的选项\nhandler: 脚本的处理函数，支持 async/await\n")])])]),s("p",[t._v("这么做是为了实现脚本和命令的统一，以及整个 Semo 代码风格的统一，脚本和命令都是支持参数选项的，区别主要是脚本大多是处理一些临时需求，不会长期存在，而命令则是整个系统的一部分，是会不断使用和强化的。")]),t._v(" "),s("h2",{attrs:{id:"脚本的管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#脚本的管理"}},[t._v("#")]),t._v(" 脚本的管理")]),t._v(" "),s("p",[t._v("首先从自动生成的名字可以看出脚本的创建时间，另外，推荐在每个脚本头部写下比较详细的注释，包括但不限于背景，用途，用法，注意事项等等。\n另外，可以在脚本目录建分类子目录，例如 "),s("code",[t._v("archive")]),t._v("，让脚本目录下直接放置的都是最活跃使用的脚本，其余放置到不同类型的目录里，方便再次需要时快速查找。")])])}),[],!1,null,null,null);a.default=r.exports}}]);