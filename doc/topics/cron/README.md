# 计划任务管理

## 为什么

很多项目都有计划任务的需求，当然也有很多 npm 包能够提供定时触发的功能，再不济我们还可以用 `setInternal` 方法进行定时。但是这里面有几个问题不是很好解决

1. 把定时任务和接口服务写在一个进程里，万一计划任务异常影响到接口服务稳定性怎么办？
2. 如果我的定时任务只是定时触发一个 shell 脚本怎么办？
3. 如果我线上是多实例部署，怎么保证计划任务执行的唯一性？

当然，这些问题都能够找到解决方法，但是每个项目可能都要重复遇到，而且对于微服务的架构，服务众多，这种重复投入是一种浪费。

目前脚手架内置了 `semo-plugin-cron` 的计划任务机制，能够解决上面的3个问题。

1. 计划任务和接口服务在不同的进程里，相互影响较小。
2. 计划任务的写法支持Shell 命令的形式
3. 通过 Redis 锁机制，解决多实例部署时计划任务之间互相干扰

另外，还有一些别的**特性**：

1. 实现了简单的计划任务管理，每个计划任务一个文件，思路和管理脚本，命令，数据库迁移文件类似。
2. 计划任务可以临时禁用
3. 计划任务可以指定生效的环境
4. 一个计划任务可以定义多个动作，依次调用

## 使用脚手架新建计划任务

脚手架提供了自动生成计划任务样板代码的功能，如下：

```bash
npm install semo-plugin-cron
semo generate cron demo
./bin/semo/crons/20190426112934195_demo.js created!
```

生成的计划任务在指定目录，文件名有统一的规律，类似于脚本和数据库迁移文件。生成的代码类似如下：

```js
const sleep = ms => new Promise(resolve => setTimeout(resolve, ms))

// 示例 Job Actions
const demoAction = async function demo () {
  console.log('I am a test cron job action')
  await sleep(100)
}

export const schedule = '*/5 * * * * *'
export const duration = 4999 // 为了避免临界条件，锁定时间要小于计划执行周期，大于任务实际执行时间
export const actions = [demoAction, ['date', ['+%Y-%m-%dT%H:%M:%S']]]
export const disabled = false // 做为测试任务，正常情况下是禁用的
export const env = 'production' // 指定运行环境，如果不指定则在所有环境都可以触发

```

示例代码想传递几个信息，一个是大致的计划任务怎么写，另外，就是关于时间，这里有三个时间

1. 计划任务本身的执行时间，这里通过 `sleep` 函数模拟
2. 计划任务的执行周期
3. `duration` 代表加锁的时间

一般来说，这个需要开发计划任务的工程师自己来评估，大致要满足： `计划任务执行周期 > 加锁周期 > 任务的执行时间`，如果不满足，可能会发生几种现象

1. `加锁周期 > 计划任务周期`，下次触发还在锁定当中，相当于计划任务周期延长了。
2. `任务执行时间 > 加锁周期`，这种比较危险，因为任务没有执行完，已经没有锁了，这时一定不要再触发计划任务。如果计划任务的执行周期设置的不是很短，主要是考虑多实例的情况，只要不同的实例的时钟差别没有那么大，理论上也不会出现重复触发的情况。
3. `任务执行时间 > 计划任务周期`，这种应该避免，因为任务的性质不同，如果每个人涉及到一取一存，由于没有执行到存储环节，可能导致下次取出现异常。但是如果是消费队列，就不会有太大的影响，这里一般都是具体问题具体分析。

`actions` 支持设置一个 `Promise` 函数作为计划任务，也支持一个 Shell 命令，Shell 命令的写法支持两种，推荐用数组这种，如果用字符串，在切割解析的时候可以会出错（原因主要是引号的干扰）。

::tip
注意，这里加锁机制在进行跨项目的隔离是用的是项目根目录的 package.json 里的 name，也就是两个项目如果 package.json 的 name 是相同的，比如都基于本脚手架起项目，但是没有改名字，如果恰好两个项目的计划任务的 key 又是相同的，可能会导致锁的相互干扰，为了避免这种干扰一方面是注意项目名的唯一性，另一方面是尽量使用 `semo make cron` 生成样板代码，会有随机的计划任务文件名，如果是自定义文件名，会增大和其他相互冲突干扰的几率。
::

## 计划任务的定义

每个计划任务都是一个普通的 node 模块，需要返回一个对象，对象包含4个属性

```
schedule: 基于 `node_cron` 包实现的，可以参考其文档进行设置，这里支持最小秒级触发，例如： '* * * * * *'
duration: 锁定时间，内部基于 Redis 锁，Redis 基于公司的底层 Redis 服务，自动连接，并且不依赖业务项目。
actions: 计划任务，是一个数组，每一项可以是一个 `Promise` 函数，也可以是代表 shell 命令的字符串或数组。
disabled: 是否禁用这个计划任务。
env: 指定计划任务的运行环境，如果不指定则在所有环境都可以出发，例如：`env: 'production'`
```

## 单独执行一个计划任务

多用于开发和调试，不使用计划任务周期触发，而是通过命令来触发，以上面新建的计划任务为例，只需要执行下面的命令，就触发单个计划任务

```
semo cron bin/semo/crons/20190426112934195_demo.js
```

## 内置 test 计划任务的作用

首先当然还是提示大家一个计划任务长什么样子，另外，其默认是禁用状态，当首次启动时，可以开启，验证计划任务是否正常工作。

## 不需要计划任务

不是所有的服务都需要计划任务，当你不需要时，可以修改部署流程的 pm2.yml，把启动计划任务的代码先删掉或者注释掉。

## 其他计划任务方案

计划任务有很多种实现方案，例如系统的 crontab，k8s 也有计划任务机制，更复杂的，有分布式的任务调度系统等等，所以这里并不强制大家必须使用这种方案，只是当大家要自己写代码实现计划任务时参考一下这种方案。
